import theano as T
import numpy as np

def get_distribution(loss_type):
    if loss_type == "gauss":
        return dist.make_G()
    elif loss_type == "exp":
        return make_E()
    elif loss_type == "cauch":
        return make_C()
    elif loss_type == "spikenslab":
        return make_SS()
    else:
        print("error! Loss function not recognized")
        exit()

def make_gauss():

    def f(latvals):
        return -(latvals**2).sum(axis = 2)
    
    def dist(x,y):
        return np.random.randn(x,y)

    return f,dist
    
def make_SS(s1 = .1,s2 = 1.,S = .05):

    def f(latvals):
        return T.log((1-S)*(T.exp(-((latvals/s1)**2)/2) / T.sqrt(2 * np.pi * (s1**2))) + S*(T.exp(-((latvals/s2)**2)/2) / T.sqrt(2 * np.pi * (s2**2)))).sum(axis = 2)

    def dist(x,y):
        a = np.random.uniform(0,1,[x,y])
        a[a > S] = 0
        a[a < 1] = 1
        
        b = np.random.randn(x,y)*s1
        c = np.random.randn(x,y)*s2
        
        return c*a + b*(1-a)

    return f,dist

def make_sym_SS(s1 = .1,s2 = 1.,S = .05):

    def f(latvals):
        ls = (latvals**2).sum(axis = 2)
        return - (ls/(2*s2*s2)) - T.log(s2*s2) + T.log(1 + (T.exp(-ls * (1./(s1*s1) - 1./(s2*s2)) /2)) * T.sqrt(s2*s2 /(s1*s1)))

    def dist(x,y):
        a = np.random.uniform(0,1,[x,y])
        a[a > S] = 0
        a[a < 1] = 1
        
        b = np.random.multivariate_normal(np.zeros(y),np.identity(y),x)*s1
        c = np.random.multivariate_normal(np.zeros(y),np.identity(y),x)*s2
        
        return c*a + b*(1-a)
        
    return f,dist

def make_E():
    def f(latvals):
        exp = (-T.abs_(latvals)).sum(axis = 2)
        return exp
    def dist(x,y):
        return np.random.laplace(0,1,[x,y])

    return f,dist
    
def make_C():
    def f(latvals):
        return -T.log(1. + latvals**2).sum(axis = 2)

    def dist(x,y):
        return np.random.standard_cauchy([x,y])
    
    return f,dist

